#!/usr/bin/env ruby
#/ Usage: provisioning-profiles [command] [options]...
#/
#/ General options:
#/     -v              Speak out what's happening
#/ 
#/ provisioning-profiles purge        Purge expired profiles
#/     Options:
#/     --dry-run       Don't delete, merely print out what would've
#/                     been deleted.
#/
#/ provisioning-profiles list         List provisioning profiles
#/     Options:
#/     -a <filter>     Filter profiles by application identifier
#/     -t <filter>     Filter profiles by team name or identifier
#/

$stderr.sync = true
require 'optparse'
require 'tempfile'
require 'date'

OPTIONS = {}
OPTIONS[:verbose] = false
OPTIONS[:dry_run] = false
OPTIONS[:team_filter] = nil
OPTIONS[:app_filter] = nil

file = __FILE__
ARGV.options do |opts|
 	opts.on("-v", "--verbose")          { OPTIONS[:verbose] = true }
 	opts.on("-d", "--dry-run")          { OPTIONS[:dry_run] = true }
	opts.on("-t", "--team=val", String) { |val| OPTIONS[:team_filter] = val }
	opts.on("-a", "--app=val", String)  { |val| OPTIONS[:app_filter] = val }
	opts.on_tail("-h", "--help")        { exec "grep ^#/<'#{file}'|cut -c4-" ; exit(0) }
	opts.parse!
end

def profile_dir
	"#{ENV['HOME']}/Library/MobileDevice/Provisioning Profiles/"
end

def provisioning_profiles
  files = %x[find "#{profile_dir}" -name "*.mobileprovision"].split("\n")
  parsed_profiles = files.map { |p| parse_provisioning_profile(p) }
  parsed_profiles.sort_by { |p| p[:team_name] }
end

def parse_provisioning_profile(file_path)
  tmpfile = Tempfile.new(File.basename(file_path))
  %x[security cms -D -i "#{file_path}" 1> #{tmpfile.path} 2> /dev/null]
  team_identifier = %x[/usr/libexec/PlistBuddy -c "Print :TeamIdentifier:0" "#{tmpfile.path}"].strip
  profile_name = %x[/usr/libexec/PlistBuddy -c "Print :Name" "#{tmpfile.path}"].strip
  team_name = %x[/usr/libexec/PlistBuddy -c "Print :TeamName" "#{tmpfile.path}"].strip
  app_identifier = %x[/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" "#{tmpfile.path}"].strip
  if app_identifier.start_with?("#{team_identifier}.")
  	app_identifier = app_identifier["#{team_identifier}.".size..-1]
  end
  creation_date = DateTime.parse(%x[/usr/libexec/PlistBuddy -c "Print :CreationDate" "#{tmpfile.path}"].strip)
  expiry_date = DateTime.parse(%x[/usr/libexec/PlistBuddy -c "Print :ExpirationDate" "#{tmpfile.path}"].strip)
  return {
    :name => profile_name,
  	:team_name => team_name,
  	:team_id => team_identifier,
  	:app_id => app_identifier,
  	:file => File.absolute_path(file_path),
  	:created => creation_date,
  	:expires => expiry_date,
  	:expired => expiry_date < DateTime.now
  }
end

def read_profiles
	all_provisioning_profiles = provisioning_profiles
	puts "Total of #{all_provisioning_profiles.size} provisioning profiles in #{profile_dir}" if OPTIONS[:verbose]
	return all_provisioning_profiles
end

def delete_profile(p)
	return false if p.nil? or not File.exist?(p[:file])
	if OPTIONS[:verbose] or OPTIONS[:dry_run]
  		puts "Deleting \"#{p[:file]}\"\t(#{p[:team_id]}.#{p[:app_id]}, expired on #{p[:expires].strftime("%Y-%m-%d")})"
  	end
  	unless OPTIONS[:dry_run]
  		%x[rm "#{p[:file]}"]
  	end
  	true
end

def purge_expired_profiles(profiles = nil)
	profiles = read_profiles if profiles.nil?
	expired_provisioning_profiles = profiles.select { |p| p[:expires] < DateTime.now }
	puts "#{expired_provisioning_profiles.size} expired provisioning profiles" if OPTIONS[:verbose]
	expired_provisioning_profiles.each_with_index do |p,i|
		delete_profile(p)
	end
end

def purge_older_profiles(profiles = nil)
	profiles = read_profiles if profiles.nil?
	purge_expired_profiles(profiles)
	profiles_by_app_id = profiles.group_by { |p| p[:app_id] }
	profiles_by_app_id.keys.each do |key|
		list = profiles_by_app_id[key].sort_by { |p| p[:creation_date] }
		while list.size > 1
			p = list.shift
			delete_profile(p)
		end
	end
end

def list_profiles
	matching_provisioning_profiles = provisioning_profiles
	unless OPTIONS[:team_filter].nil?
		matching_provisioning_profiles = matching_provisioning_profiles.select do |p|
			p[:team_name].downcase.include?(OPTIONS[:team_filter].downcase) or p[:team_id].downcase.include?(OPTIONS[:team_filter].downcase)
		end
	end
	unless OPTIONS[:app_filter].nil?
		matching_provisioning_profiles = matching_provisioning_profiles.select do |p|
			p[:app_id].downcase.include?(OPTIONS[:app_filter].downcase)
		end
	end
  sorted_matching_provisioning_profiles = matching_provisioning_profiles.sort_by { |p|
    "#{p[:team_name]}.#{p[:app_id]}.#{p[:expires].strftime('%Y-%m-%d')}.#{p[:name]}"
  }
	sorted_matching_provisioning_profiles.each_with_index do |p,i|
		parts = []
		parts << File.basename(p[:file])
		expiry_date = p[:expires].strftime('%Y-%m-%d')
		expiry_date = (p[:expired] ? "expired on #{expiry_date}" : "expires on #{expiry_date}") if OPTIONS[:verbose]
		parts << expiry_date
		parts << "#{p[:team_id]}.#{p[:app_id]}"
		if OPTIONS[:verbose]
      parts << "\"#{p[:name]}\""
			parts << "\"#{p[:team_name]}\""
		end
  		puts parts.join(' ')
	end
end

command = ARGV.first || "list"
if command == "purge"
	purge_expired_profiles
elsif command == "purge-old"
	purge_older_profiles
elsif command == "list"
	list_profiles
else
	exec "grep ^#/<'#{file}'|cut -c4-" ; exit(1)
end
